	$d1$, $d2$, $d3$, $d4$, $d5$, $d6$, $d7$ y $d8$ serán los valores de los dígitos de tu DNI o pasaporte, donde $d1$
	es tu primer dígito. Si te faltan dígitos, añades ceros. Así, $d1d2d3d4d5d6d7d8$ será un número de 8 cifras.
	
	Dado tu número de 8 cifras, $n$:
	\begin{enumerate}
		\item Con el algoritmo de la exponencialización rápida, calcula sus $a-sucesiones$ para los 5 primeros primos.
		\item ¿Qué dice el test de Solovay-Strassen para esas 5 bases? ¿Con qué probabilidad tu $n$ es primo?
	\end{enumerate}

\section*{Solución}
	Lo primero que calcularemos es $n$, que en mi caso sería $n = 26050919 =_b 0001 1000 1101 1000 0001 0110 0111$
	
	\begin{enumerate}
		\item El algoritmo que he utilizado es el de exponencialización rápida de izquierda a derecha modificado
		para que en cada iteración $i$ calcule $a^{exp_i} \mod{n}$ en lugar de $a^{exp_i}$ para poder tratar el
		número pues de otro modo sería intratable. El algoritmo es el siguiente:
		\begin{algorithm}[H]
			\begin{algorithmic}[1]
				\REQUIRE \ \\
					\texttt{$a$}, base \\
					\texttt{$b =_b e_je_{j-1}e_{j-2}\dots e_2e_1e_0$}, exponente y su expresión en binario \\
					\texttt{$c$}, módulo\\ \
				\STATE{\texttt{$acu = 1$}}
				\STATE{\texttt{$exp = 0$}}
				\STATE{\texttt{$i = j$; $j$ es el número de dígitos en binario de $b$}}
				\WHILE{\texttt{$i > 0$}}
					\STATE{\texttt{$acu \equiv acu^2 \mod{c}$ }}
					\STATE{\texttt{$exp = 2 \cdot exp$}}
					\IF{\texttt{$e_i = 1$}}
						\STATE{\texttt{$acu \equiv acu \cdot a \mod{c}$}}
						\STATE{\texttt{$exp = exp + 1$}}
					\ENDIF
					\STATE{\texttt{$i = i - 1$}}
				\ENDWHILE
				\PRINT{\texttt{$acu$, $exp$}}
			\end{algorithmic}
			\caption{Exponencialización rápida de izquierda a derecha}
			\label{Fast-exp}
		\end{algorithm}
		
		Dado que $\displaystyle \frac{n-1}{2} = 13025459$ es impar, las $a-sucesiones$ tendrás sólo 2 términos.
		
		\begin{enumerate}
			\item Para $a = 2$ tenemos:
				$acu = 2^{13025459} \equiv 3764029$
				$acu = 2^{26050918} \equiv 17811015$
				
			\item Para $a = 3$ tenemos:
				$acu = 3^{13025459} \equiv 21679447$
				$acu = 3^{26050918} \equiv 11610658$
				
			\item Para $a = 5$ tenemos:
				$acu = 5^{13025459} \equiv 6820151$
				$acu = 5^{26050918} \equiv 22769921$
				
			\item Para $a = 7$ tenemos:
				$acu = 7^{13025459} \equiv 16034947$
				$acu = 7^{26050918} \equiv 2720332$
				
			\item Para $a = 11$ tenemos:
				$acu = 11^{13025459} \equiv 14340865$
				$acu = 11^{26050918} \equiv 22153099$
				
			Claramente, $n$ es compuesto. De hecho, no engaña a ningún $a$ primo tomado.
		\end{enumerate}
		
		\item El algoritmo que he utilizado es el de cálculo del símbolo de Jacobi\footnote{Este valor coincide
		con el símbolo de Legendre cuando $n$ es un primo impar.} excepto para el caso del primo 2. El algoritmo
		es el siguiente:
		\begin{algorithm}[H]
			\begin{algorithmic}[1]
				\REQUIRE \ \\
					\texttt{$a$}, elemento \\
					\texttt{$n$}, base \\ \
				\STATE{\texttt{$t = 1$}}
				\STATE{\texttt{$m = |n|$}}
				\STATE{\texttt{$b \equiv a \mod m$}}
				\WHILE{\texttt{$b != 0$}}
					\WHILE{\texttt{$b$ par}}
						\STATE{\texttt{$\displaystyle b = \frac{b}{2}$}}
						\IF{\texttt{$m \mod 8 \in \{3, 5\}$}}
							\STATE{\texttt{$t = -t$}}
						\ENDIF
					\ENDWHILE
					\STATE{\texttt{$(b, m) = (m, b)$}}
					\IF{\texttt{$b \equiv m \equiv 3 \mod 4$}}
						\STATE{\texttt{$b \equiv b \mod{m}$}}
						\STATE{\texttt{$t = -t$}}
					\ENDIF
				\ENDWHILE
				\IF{\texttt{$m = 1$}}
					\PRINT{\texttt{$t$}}
				\ELSE
					\PRINT{\texttt{$0$}}
				\ENDIF
			\end{algorithmic}
			\caption{Símbolo de Jacobi}
			\label{Jac-symbol}
		\end{algorithm}
	\end{enumerate}